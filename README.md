<!--
[![Contributors][contributors-shield]][contributors-url]
[![Forks][forks-shield]][forks-url]
[![Stargazers][stars-shield]][stars-url]
[![Issues][issues-shield]][issues-url]
[![MIT License][license-shield]][license-url]
[![LinkedIn][linkedin-shield]][linkedin-url]
-->


# Reliquae

A topdown game built in C# .NET Core with Monogame and my own Entity-Component-System. Build structures, fight monsters, establish farms, fish, and explore in this story-driven game!

<!-- TABLE OF CONTENTS -->
<details open="open">
  <summary>Table of Contents</summary>
  <ol>
    <li><a href="#implementation">Implementation</a>
      <ul>
        <li><a href="#Components">Entity Component System</a></li>
        <li><a href="#world">World</a></li>
        <li><a href="#tilemap">Tile Maps</a></li>
        <ul>
          <li><a href="#blockdata">Block Data</a></li>
        </ul>
      </ul>
    </li>
    <li><a href="#gameplay">Gameplay</a></li>
    <li><a href="#installation">Installation</a></li>
    <li><a href="#roadmap">Roadmap</a></li>
    <li><a href="#license">License</a></li>
    <li><a href="#acknowledgements">Acknowledgements</a></li>
  </ol>
</details>


## Implemenatation

### Components

The Entity Component System I have programmed is the core of this game. Every single Entity in the game, whether it be a static path decoration, a monster, or the player itself is stored in a class which contains only its data. These classes will implement a set of interfaces (which all inherit from `IComponent`) which will provide a template for the properties which need to be provided. Implementing this interface will add any instance created to the list of components registered by any and all Systems which look over these sets of components. These systems will perform the necessary calculations and establish the interactions between Component objects. For example, the `PhysicsSystem` provides movement to all objects with a `IKinetic` component. Here is a list of all available Component interfaces:

  - `ITransform : IComponent` - Basic `Transform` Component that holds positional information. All objects with `Transforms` are given to the `PhysicsSystem`.
    - `IKinetic : ITransform` - Represents an object that can move (is not static). The movement will be handled by the `PhysicsSystem`.
    - `ISprite : ITransform` - If present, the `ActiveTexture` will be drawn to the screen at the `Transform's` Position by the `RenderSystem`.
        - `IColliderTransform : ISprite` - Represents any object that has a collider.
          - `ISolid : IColliderTransform` - Represents any object who's collider is solid.
          - `ITrigger : IColliderTransform` - Represents any object who's collider is simply a trigger.

### World

The world of the game data is stored in the `World` class. It contains a `Tape` (custom data structure) of a tuple containing a `TileMap` and an `EntityMap`.
Each node in the `Tape` represents one layer of the world. For example, the starting tilemap is the base ground level and the starting entity map describes all static and non-static entities on the ground level. The layer below on the tape might represent the mining area directly underneath ground level.

### Tile-Maps

Time-maps contain a 2D-array of `Tiles`. This map can be saved and loaded from memory. 
When loaded, the blockdata will be used to automatically select the textures based on adjacency patterns.
For example, if there is dirt adjacent to a grass tile, the grass tile will select a texture which shows the intersection of the two tiles.
With two regular intersecting tiles, there can be over 40 different intersections which are all auto-generated through the Blockdata.

### Blockdata

In the Content folder there is a set of blockdata json files which contain the information and tilemap patterns for each tile type (dirt, grass, etc.)
The extension of these files determines the file schema. All schemas represent an `BlockModel<T>` where `T` is an `IAdjacencyModel` (which is then converted to the matching `IAdjacencyPattern`). These can be designed manually or autogenerated using the `BlockDataGenerator` Console App by simply providing it with a pattern template bitmap. The algorithm will look at all the 3x3 patterns in order and will prompt the user for the Block Name for
each unique color it comes across in the patterns. It will output a generated pattern json.

The available format options are:

 - `DirectAdjacencyModel/Pattern` (*name_d.json*) - Simplest patterns which matches on only the directly adjacent tiles ( W N E S )
 - `SingleAdjacencyModel/Pattern` (*name_s.json*) - Simple patterns which match on all adjacent tiles ( W NW N NE E SE S SW )
 - `DirectRandomAdjacencyModel/Pattern` (*name_dr.json*) - DirectAdjacency but multiple textures can be listed with random weights
 - `SingleRandomAdjacencyModel/Pattern` (*name_sr.json*) - SingleAdjacency but multiple textures can be listed with random weights

## Gameplay

![gameplay](https://github.com/RyanAlameddine/Reliquae/raw/master/READMEContent/reliquae.gif)

## Installation

This project is currently in development. There is no published version, but feel free to download the project and build it yourself!

## Roadmap

See the [open issues](https://github.com/RyanAlameddine/Reliquae/issues) for a list of proposed features (and known issues).

## License

Distributed under the MIT License. See `LICENSE` for more information.

## Acknowledgements
* [Sofia Echvarria](https://github.com/21EchavarriaS) - Game Design and Art
* [Ryan Alameddine](https://github.com/RyanAlameddine) - Game Design and Programming
